# Deployment Process

Code goes through several steps to get to production. This document describes this process. It should also be noted that this is the same flow for both content and code changes.

## Automated Deployment Schedule

| Application | Branch | Changes in by | Deployment Start | Release History |
| --- | --- | --- | --- | --- |
| vets-website | master | 2:00pm ET M-F | 3:00pm ET M-F| https://github.com/department-of-veterans-affairs/vets-website/releases |
| vets-api | master | 2:00pm ET M-F | 3:00pm ET M-F | https://github.com/department-of-veterans-affairs/vets-api/releases |

## Summary

For feature and hotfix development (code changes and content changes), the process looks like:

1. Dev/Content: Create feature branch from `master` branch
1. Dev/Content: Commit changes to feature branch
1. Dev/Content: Feature branch merged to the `master` branch (via Pull Request)
1. Automatic: Build run from `master` branch to create an artifact
1. Automatic: Deploy newly created artifact to dev and staging
1. Automatic: Create a release in GitHub from master, tag artifacts of that commit sha with release name
1. Automatic: Deploy to production using artifacts

## Process Details

The first half of the steps of are:

> 1\. Dev: Create feature branch from `master` branch

> 2\. Dev: Commit changes to feature branch

> 3\. Dev: Feature branch merged to the `master` branch (via Pull Request)

> 4\. Automatic: Build run from `master` branch to create an artifact

> 5\. Automatic: Deploy newly created artifact to dev and staging

These steps follow the flow as described in the [Continuous Integration Process](Continuous%20Integration%20Process.md). The parts that should be explicitly called out are that during the pull request phase (step 3), the following things happen:

- Code is reviewed
- GitHub triggers Jenkins to run unit tests, linting, and security scans.
- Committing and code reviewing developers are responsible for running automated **_and_** manual integration tests locally before closing the pull request

All Vets.gov GitHub repos are setup to do squash merges (via the GitHub PR interface), leaving behind a clean revision history that is feature based.

A big assumption in this process is that the `master` should always be deployable. As such, the deployment to the staging environment is configured to happen automatically and can be used to see what something would look like in a production-like environment for any kind of manual testing/verification.

Because `master` is designed to always be deployable, long running features that should _not_ be deployed should utilize feature flags in the code that disable the feature for the actual production environment. Notifying the DevOps team on what feature flags should be enabled/disabled in staging and production environment is an important part of this process. However, it's likely that breakages in staging will occur and that this is necessary to discover these prior to moving anything to the production steps.

Speaking of production steps, things kick off with the daily production push

> 6\. Create a release in GitHub from master, tag artifacts of that commit sha with release name

Every work day at the configured time a [Jenkins automerge job](http://jenkins.vetsgov-internal/job/deploys/job/vets-gov-automerge/) sends a link to the #vetsgov-engineers Slack channel with a diff between the last release and the most recent changes in `master`. This commit reference is stored to ensure the diff and released version is deterministic.

After a time has elapsed ( currently set to 60m ) release is created at the reference from above.

> 7\. Automated: Deploy to production using artifacts

From here, Jenkins can kickoff a production deployment. After the deployment occurs, the normal site monitoring infrastructure will be used to valide it is working. As this process is automatic any new features should have monitoring in place before, or as a part of their deployment

## Other Notes

- The code that appears in the `master` branch _actually_ gets deployed to both dev and staging environments. This is done to support different configurations for the DevOps team as they work to support any configuration changes (i.e. in dev first).

## Deployment Rollbacks

If a production deployment introduces issues that affect Service Level Objectives (SLOs) established for the project, the DevOps team may restore service to users by rolling back the deployment. This is accomplished by triggering a new deploy job in Jenkins using a previous release tag.

The use of hotfixes is discouraged, but may be useful in an emergency situation when `master` has significantly deviated from the release and a fix to the failed production release is critical. To create a hotfix, create a branch from the last stable release tag, make changes necessary (with review), create a new release tag following the correct naming scheme, and trigger a deploy in Jenkins with the release name as a parameter.

If SLOs are not affected and a fix is not critical, no rollback will be issued. Instead the fix should be applied through the standard development workflow.

# Getting a change from Drupal or vagov-content into production

If your change is in Drupal, skip to the next section.

## Merge content change in vagov-content
1. When you get a PR request in `vagov-content`, wait for the build checks to pass and for the PR to be mergeable
   - If there's an issue with the build check, you may need to restart it (click on the Jenkins link in the PR to open it)
2. Merge the PR in `vagov-content` into master
3. Wait for Jenkins to build the change in `vets-website`. You should see a running build here: http://jenkins.vetsgov-internal/blue/organizations/jenkins/testing%2Fvets-website/activity?branch=master
   - If this build fails, you may need to log into Jenkins and restart it
4. Once the build succeeds, the change is on dev and staging, and ready for the next production deploy

## If you need to immediately deploy only content changes to production (and no new vets-website changes)
1. Start a deploy job
   - Go to http://jenkins.vetsgov-internal/job/deploys/job/vets-gov-autodeploy-vets-website/
   - Log into Jenkins if you haven't yet
   - Choose Build with Parameters
   - Set the release_wait option to something like 5-10 minutes, depending on how much time you want to give yourself or others to respond
   - Click the checkbox for use_latest_release
   - Click Build
   - In Slack, the notification that happens in the vetsgov-engineers channel will have a link that shows the exact commits being released, re-check these to make sure they're safe
2. Once the build finishes, check production to see that the changes are live

## If you need to immediately deploy the change to production, including undeployed vets-website changes
1. Validate that the changes since the last deploy are safe to deploy, and include any vets-website commits you need:
   - You can check the build history at http://jenkins.vetsgov-internal/job/deploys/job/vets-gov-autodeploy-vets-website/ to get the time of the last deploy (usually daily at 2pm EST)
   - Look for commits after the last deploy: https://github.com/department-of-veterans-affairs/vets-website/commits/master
   - You may need to contact the developers of those commits to verify for sure
2. Start a deploy job
   - Go to http://jenkins.vetsgov-internal/job/deploys/job/vets-gov-autodeploy-vets-website/
   - Log into Jenkins if you haven't yet
   - Choose Build with Parameters
   - Set the release_wait option to something like 5-10 minutes, depending on how much time you want to give yourself or others to respond
   - Click Build
   - In Slack, the notification that happens in the vetsgov-engineers channel will have a link that shows the exact commits being released, re-check these to make sure they're safe
3. Once the build finishes, check production to see that the changes are live